# 依赖注入 (Dependency Injection)

> ZGO 使用 Google Wire 实现编译时依赖注入，零运行时开销。

## 为什么选择 Wire？

| 方案 | 类型 | 优点 | 缺点 |
|------|------|------|------|
| **Wire** | 编译时 | 类型安全、零开销、显式依赖 | 需要代码生成 |
| uber/fx | 运行时 | 灵活、生命周期管理 | 运行时错误、反射开销 |
| dig | 运行时 | 简单 | 运行时错误 |
| 手动注入 | 无 | 完全控制 | 繁琐、易出错 |

Wire 的优势：
- ✅ 编译时检查依赖是否完整
- ✅ 零运行时开销（生成的是普通 Go 代码）
- ✅ 依赖关系清晰可见
- ✅ IDE 支持（跳转、重构）

## 核心概念

### Provider (提供者)

Provider 是一个返回依赖的函数：

```go
// 简单 Provider
func NewUserRepository(db *gorm.DB) *UserRepositoryImpl {
    return &UserRepositoryImpl{db: db}
}

// 带错误的 Provider
func NewConfig() (*Config, error) {
    return LoadConfig()
}

// 带清理的 Provider
func NewDBConnection() (*gorm.DB, func(), error) {
    db, err := gorm.Open(...)
    cleanup := func() { db.Close() }
    return db, cleanup, err
}
```

### ProviderSet (提供者集合)

将相关的 Provider 组合在一起：

```go
// internal/modules/user/provider.go
var ProviderSet = wire.NewSet(
    // 构造函数
    NewRepository,
    NewService,
    NewHandler,
    
    // 接口绑定
    wire.Bind(new(Repository), new(*UserRepositoryImpl)),
    wire.Bind(new(Service), new(*UserServiceImpl)),
)
```

### wire.Bind (接口绑定)

告诉 Wire 用哪个实现满足接口：

```go
// 当需要 Repository 接口时，提供 *UserRepositoryImpl
wire.Bind(new(Repository), new(*UserRepositoryImpl))
```

### wire.Struct (结构体注入)

自动填充结构体字段：

```go
type App struct {
    Config   *config.Config
    DB       *gorm.DB
    Handlers *Handlers
}

// 自动注入所有字段
wire.Struct(new(App), "*")

// 只注入指定字段
wire.Struct(new(App), "Config", "DB")
```

## 实战示例

### 1. 模块 Provider

```go
// internal/modules/user/provider.go
package user

import "github.com/google/wire"

var ProviderSet = wire.NewSet(
    // Repository
    NewRepository,
    wire.Bind(new(Repository), new(*UserRepositoryImpl)),
    
    // Service
    NewService,
    wire.Bind(new(Service), new(*UserServiceImpl)),
    
    // Handler
    NewHandler,
)
```

### 2. 构造函数

```go
// internal/modules/user/repository.go
func NewRepository(db *gorm.DB) *UserRepositoryImpl {
    return &UserRepositoryImpl{db: db}
}

// internal/modules/user/service.go
func NewService(
    repo Repository,           // 依赖接口
    hasher *hash.Hasher,
    jwt *jwt.Service,
    email *email.Service,
) *UserServiceImpl {
    return &UserServiceImpl{
        repo:   repo,
        hasher: hasher,
        jwt:    jwt,
        email:  email,
    }
}

// internal/modules/user/handler.go
func NewHandler(service Service) *Handler {
    return &Handler{service: service}
}
```

### 3. Wire 配置

```go
// internal/wiring/wire.go
//go:build wireinject
// +build wireinject

package wiring

import (
    "github.com/google/wire"
    "github.com/zgiai/zgo/internal/app"
    "github.com/zgiai/zgo/internal/infra/config"
    "github.com/zgiai/zgo/internal/infra/database"
    "github.com/zgiai/zgo/internal/infra/email"
    "github.com/zgiai/zgo/internal/infra/jwt"
    "github.com/zgiai/zgo/internal/modules/permission"
    "github.com/zgiai/zgo/internal/modules/user"
    "github.com/zgiai/zgo/pkg/hash"
)

func InitializeApp() (*app.Application, func(), error) {
    wire.Build(
        // 基础设施
        config.MustLoad,
        database.NewDB,
        jwt.NewService,
        email.NewService,
        hash.NewHasher,
        
        // 业务模块
        user.ProviderSet,
        permission.ProviderSet,
        
        // 应用容器
        wire.Struct(new(app.Handlers), "*"),
        wire.Struct(new(app.Application), "*"),
    )
    return nil, nil, nil
}
```

### 4. 生成代码

```bash
cd internal/wiring && wire
```

生成的 `wire_gen.go`：

```go
// Code generated by Wire. DO NOT EDIT.

package wiring

func InitializeApp() (*app.Application, func(), error) {
    configConfig := config.MustLoad()
    db, cleanup, err := database.NewDB(configConfig)
    if err != nil {
        return nil, nil, err
    }
    
    jwtService := jwt.NewService(configConfig)
    emailService := email.NewService(configConfig)
    hasher := hash.NewHasher()
    
    userRepository := user.NewRepository(db)
    userService := user.NewService(userRepository, hasher, jwtService, emailService)
    userHandler := user.NewHandler(userService)
    
    permissionRepository := permission.NewRepository(db)
    permissionService := permission.NewService(permissionRepository)
    permissionHandler := permission.NewHandler(permissionService)
    
    handlers := &app.Handlers{
        User:       userHandler,
        Permission: permissionHandler,
    }
    
    application := &app.Application{
        Config:   configConfig,
        DB:       db,
        Handlers: handlers,
    }
    
    return application, cleanup, nil
}
```

### 5. 使用

```go
// cmd/server/main.go
func main() {
    app, cleanup, err := wiring.InitializeApp()
    if err != nil {
        log.Fatal(err)
    }
    defer cleanup()
    
    kernel := bootstrap.NewHttpKernel(app)
    kernel.Handle()
}
```

## 添加新模块

### 步骤 1: 创建模块

```bash
./zgo make:module Blog
```

### 步骤 2: 定义 Provider

```go
// internal/modules/blog/provider.go
package blog

import "github.com/google/wire"

var ProviderSet = wire.NewSet(
    NewRepository,
    wire.Bind(new(Repository), new(*BlogRepositoryImpl)),
    NewService,
    wire.Bind(new(Service), new(*BlogServiceImpl)),
    NewHandler,
)
```

### 步骤 3: 更新 Handlers

```go
// internal/app/app.go
type Handlers struct {
    User       *user.Handler
    Permission *permission.Handler
    Blog       *blog.Handler  // 新增
}
```

### 步骤 4: 更新 Wire 配置

```go
// internal/wiring/wire.go
func InitializeApp() (*app.Application, func(), error) {
    wire.Build(
        // ...
        user.ProviderSet,
        permission.ProviderSet,
        blog.ProviderSet,  // 新增
        // ...
    )
    return nil, nil, nil
}
```

### 步骤 5: 重新生成

```bash
cd internal/wiring && wire
```

## 测试中的依赖注入

### Mock 接口

```go
// internal/modules/user/service_test.go
type mockRepository struct {
    users map[uint]*domain.User
}

func (m *mockRepository) FindByID(ctx context.Context, id uint) (*domain.User, error) {
    if user, ok := m.users[id]; ok {
        return user, nil
    }
    return nil, domain.ErrUserNotFound
}

func TestUserService_GetProfile(t *testing.T) {
    // 创建 Mock
    repo := &mockRepository{
        users: map[uint]*domain.User{
            1: {ID: 1, Username: "test"},
        },
    }
    
    // 手动注入
    service := user.NewService(repo, hasher, jwt, email)
    
    // 测试
    profile, err := service.GetProfile(context.Background(), 1)
    assert.NoError(t, err)
    assert.Equal(t, "test", profile.Username)
}
```

### 使用 testify/mock

```go
type MockRepository struct {
    mock.Mock
}

func (m *MockRepository) FindByID(ctx context.Context, id uint) (*domain.User, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*domain.User), args.Error(1)
}

func TestUserService_GetProfile(t *testing.T) {
    repo := new(MockRepository)
    repo.On("FindByID", mock.Anything, uint(1)).Return(&domain.User{ID: 1}, nil)
    
    service := user.NewService(repo, hasher, jwt, email)
    profile, err := service.GetProfile(context.Background(), 1)
    
    assert.NoError(t, err)
    repo.AssertExpectations(t)
}
```

## 常见问题

### 循环依赖

```
wire: cycle detected
```

**解决**：通过接口打破循环

```go
// ❌ 循环依赖
type A struct { b *B }
type B struct { a *A }

// ✅ 通过接口解耦
type A struct { b BInterface }
type B struct { a AInterface }
```

### 缺少 Provider

```
wire: no provider found for *SomeType
```

**解决**：添加对应的 Provider 到 wire.Build

### 多个实现

```
wire: multiple providers for SomeInterface
```

**解决**：使用 wire.Bind 明确指定

## 与 NestJS 对比

| NestJS | ZGO (Wire) |
|--------|-------------|
| `@Injectable()` | 普通构造函数 |
| `@Module({ providers })` | `wire.NewSet(...)` |
| `@Inject()` | 构造函数参数 |
| 运行时 DI | 编译时生成 |
| 装饰器魔法 | 显式代码 |

## 下一步

- [Domain 层详解](../modules/01-domain-layer.md)
- [业务模块开发](../modules/03-business-modules.md)
