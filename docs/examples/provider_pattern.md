# Provider Pattern Example

This example demonstrates how to create a new module with dependency injection using Wire.

## Step 1: Create Module Structure

```bash
./zgo make:module Blog
```

This generates:
```
internal/modules/blog/
├── model.go
├── dto.go
├── repository.go
├── service.go
├── handler.go
├── provider.go    # ⭐ DI configuration
└── routes.go
```

## Step 2: Define Interfaces and Implementations

### Repository
```go
// repository.go
type Repository interface {
    Create(ctx context.Context, blog *Blog) error
    FindByID(ctx context.Context, id uint) (*Blog, error)
}

type RepositoryImpl struct {
    db *gorm.DB
}

func NewRepository(db *gorm.DB) *RepositoryImpl {
    return &RepositoryImpl{db: db}
}
```

### Service
```go
// service.go
type Service interface {
    CreateBlog(ctx context.Context, req *CreateRequest) (*Response, error)
    GetBlog(ctx context.Context, id uint) (*Response, error)
}

type ServiceImpl struct {
    repo Repository  // ⭐ Depends on interface, not concrete type
}

func NewService(repo Repository) *ServiceImpl {
    return &ServiceImpl{repo: repo}
}
```

### Handler
```go
// handler.go
type Handler struct {
    service Service  // ⭐ Depends on interface
}

func NewHandler(service Service) *Handler {
    return &Handler{service: service}
}
```

## Step 3: Configure Provider

```go
// provider.go
package blog

import "github.com/google/wire"

var ProviderSet = wire.NewSet(
    NewRepository,                                    // 1. Create *RepositoryImpl
    wire.Bind(new(Repository), new(*RepositoryImpl)), // 2. Bind interface → impl
    NewService,                                       // 3. Create *ServiceImpl (gets Repository)
    wire.Bind(new(Service), new(*ServiceImpl)),      // 4. Bind interface → impl
    NewHandler,                                       // 5. Create *Handler (gets Service)
)
```

**What Wire does:**
1. Calls `NewRepository(db)` → returns `*RepositoryImpl`
2. Knows `*RepositoryImpl` satisfies `Repository` interface
3. Calls `NewService(repo)` → passes the `Repository` interface
4. Knows `*ServiceImpl` satisfies `Service` interface
5. Calls `NewHandler(service)` → passes the `Service` interface

## Step 4: Register in Central Wire

```go
// internal/modules/wire.go
package app

import (
    "github.com/zgiai/zgo/internal/modules/blog"
    "github.com/google/wire"
)

type App struct {
    User       *user.Handler
    Permission *permission.Handler
    Blog       *blog.Handler  // ⭐ Add your handler
}

func InitApp(db *gorm.DB) (*App, error) {
    wire.Build(
        config.MustLoad,
        jwt.NewService,
        user.ProviderSet,
        permission.ProviderSet,
        blog.ProviderSet,  // ⭐ Add your provider
        wire.Struct(new(App), "*"),
    )
    return nil, nil
}
```

## Step 5: Generate Wire Code

```bash
cd internal/modules && wire
```

This generates `wire_gen.go`:
```go
// Code generated by Wire. DO NOT EDIT.

func InitApp(db *gorm.DB) (*App, error) {
    configConfig := config.MustLoad()
    service := jwt.NewService(configConfig)
    
    // User module
    userRepositoryImpl := user.NewRepository(db)
    userRepository := userRepositoryImpl
    userServiceImpl := user.NewService(userRepository, service)
    userService := userServiceImpl
    userHandler := user.NewHandler(userService)
    
    // Blog module ⭐
    blogRepositoryImpl := blog.NewRepository(db)
    blogRepository := blogRepositoryImpl
    blogServiceImpl := blog.NewService(blogRepository)
    blogService := blogServiceImpl
    blogHandler := blog.NewHandler(blogService)
    
    app := &App{
        User: userHandler,
        Blog: blogHandler,
    }
    return app, nil
}
```

## Benefits

✅ **Type Safety**: Compile error if dependencies are missing  
✅ **Interface-Based**: Easy to mock for testing  
✅ **Zero Runtime Cost**: Pure Go code, no reflection  
✅ **Clear Dependencies**: Constructor signatures show what's needed  

## Testing with Mocks

```go
// blog/service_test.go
type MockRepository struct {
    mock.Mock
}

func (m *MockRepository) FindByID(ctx context.Context, id uint) (*Blog, error) {
    args := m.Called(ctx, id)
    return args.Get(0).(*Blog), args.Error(1)
}

func TestGetBlog(t *testing.T) {
    mockRepo := new(MockRepository)
    service := NewService(mockRepo)  // ⭐ Inject mock
    
    mockRepo.On("FindByID", mock.Anything, uint(1)).Return(&Blog{ID: 1}, nil)
    
    result, err := service.GetBlog(context.Background(), 1)
    assert.NoError(t, err)
    assert.Equal(t, uint(1), result.ID)
}
```

## Comparison with Manual DI

### Without Wire (Manual)
```go
// routes.go - Manual wiring
func Register(r *router.Router) {
    db := database.GetDB()
    repo := NewRepository(db)
    service := NewService(repo)
    handler := NewHandler(service)
    
    r.GET("/blogs", handler.List)
}
```

### With Wire (Automated)
```go
// provider.go - Declare dependencies
var ProviderSet = wire.NewSet(
    NewRepository,
    wire.Bind(new(Repository), new(*RepositoryImpl)),
    NewService,
    wire.Bind(new(Service), new(*ServiceImpl)),
    NewHandler,
)

// wire.go - Aggregate
wire.Build(blog.ProviderSet, ...)

// Wire generates the wiring code automatically
```

**Advantages:**
- Centralized dependency graph
- Compile-time validation
- Easier refactoring (change constructor, Wire updates all call sites)
